Introduction

The goal of this lab is to apply your understanding of decision and loop
	structures to implement a complex algorithm within the context of an
	unfamiliar and significant software framework (GridWorld). In addition,
	you will implement a unit test for your program using the JUnit framework
	and create documentation for your program using JavaDoc.


Requirements

Write a program that plays Conway’s Game of Life. Conway’s Game of Life is a
	cellular automaton. From Wikipedia:

The universe of the Game of Life is an infinite two-dimensional orthogonal
	grid of square cells, each of which is in one of two possible states,
	alive or dead. Every cell interacts with its eight neighbours, which are
	the cells that are horizontally, vertically, or diagonally adjacent. At
	each step in time, the following transitions occur:

* Any live cell with fewer than two live neighbours dies, as if caused by
	underpopulation.
* Any live cell with two or three live neighbours lives on to the next generation.
* Any live cell with more than three live neighbours dies, as if by overcrowding.
* Any dead cell with exactly three live neighbours becomes a live cell, as if
	by reproduction.
* The initial pattern constitutes the seed of the system. The first
	generation is created by applying the above rules simultaneously to every
	cell in the seed—births and deaths occur simultaneously, and the discrete
	moment at which this happens is sometimes called a tick (in other words,
	each generation is a pure function of the preceding one). The rules
	continue to be applied repeatedly to create further generations.
	

Nonfunctional Requirements:

* the program must be implemented in Java and utilize the GridWorld platform
* I recommend not use GridWorld’s execution engine to produce subsequent
	generations. It will be easier to implement the unit test if you directly
	produce and display subsequent generations.


Artifacts to Produce:

* Requirements Document: Many functional and nonfunctional requirements needs
	to be defined. You must define additional requirements that are
	reasonable and document them in a requirements document. I must review
	your requirements document before you start the design document or test
	plan. You may change the requirements document throughout development.
* Design Document: You must do some design activity before starting
	implementation. This may consist of a flow cart, pseudocode, or other
	design artifact. I must review your design document before you start
	implementing code. You may change your design document throughout
	development.
* Test Plan: You must create a test plan with specific test cases (at least
	two) before starting implementation. I must review your test plan before
	you start implementing your test class. You may change your test plan
	throughout development. The provided code in GitHub is an example of
	implementing an initial test case.
* GameOfLifeTest Test Class: JUnit-compatible test class that implements the
	test plan.
* GameOfLife class: You must produce a working class the meets the
	requirements and is verified and validated by your test plan.
* Reflection Document: This is a significant and challenging lab. Please
	reflect on this experience and share your feedback with me. What did you
	like or dislike and why? What was surprising or unexpected? What did you
	learn? What questions do you still have? What advice would you offer next
	year's students?


Submission:

* Ensure the following artifacts have been committed to GitHub in addition to your code:
    * requirements document
    * design document (pseudocode, flow charts, etc.)
    * test plan (with specific test cases)
    * HTML documentation generated by JavaDoc
    * reflection document
* Submit a pull request in GitHub and submit a link to the request with this assignment.


************************************************************** 
 

Requirements Document:
Grid Size: 10 by 10
Live Cells look like red bugs (Bug Actor)
Dead Cells are null and are not displayed by any Actor
The initial pattern of the grid is hard-coded
The game runs for three generations (the initial generation is the first generation)
The time interval between each generation is 3 seconds

Design Document: (pseudocode)
1. Create a 'live' array list and a 'die' array list - if a dead cell should regenerate, its
coordinates will be added to the live array list, and if a live cell should die, its coordinates
wiil be added to the die array list
2. Loop through each coordinate on the grid one at a time and determine the number of alive neighbors
the cell has
3. If the main cell is alive and the number of alive neighbors is not 2, the cell is added to the
die array list. If the main cell is dead and the number of alive neighbors is 3, the cell is added
to the live array list
4. The grid is changed by removing all of the Actors whose coordinates are in the die array list and
by adding a new Bug Actor to the coordinates that exist in the live array list

Test Plan:
(O: alive; X: dead)

Initial Generation Pattern
  0 1 2 3 4 5 6 7 8 9
0 X X X X X X X X X X 
1 X X X X X X X X X X 
2 O O X X X X X X X X 
3 X X X O X X X X X X 
4 X X X O O X X X X X 
5 X X X X X X X X X X
6 X X X O X X X X X X
7 X X X X X X X O X X
8 X X X X X X X O X X
9 X X X X X X X X X X

Second Generation
  0 1 2 3 4 5 6 7 8 9
0 X X X X X X X X X X 
1 X X X X X X X X X X 
2 X X X X X X X X X X 
3 X X O O O X X X X X 
4 X X X O O X X X X X 
5 X X X O O X X X X X
6 X X X X X X X X X X
7 X X X X X X X O X X
8 X X X X X X X O X X
9 X X X X X X X X X X

Third Generation
  0 1 2 3 4 5 6 7 8 9
0 X X X X X X X X X X 
1 X X X X X X X X X X 
2 X X X O X X X X X X 
3 X X O X X X X X X X 
4 X X X X X O X X X X 
5 X X X X X X X X X X
6 X X X X X X X X X X
7 X X X X X X X X X X
8 X X X X X X X X X X
9 X X X X X X X X X X

Reflection Document:

For me, the most challenging aspect of this lab wasn't necessarily determining the algorithm to use, 
but rather, figuring out how to translate my original pseudocode/algorithm into working code. Really,
the majority of time on this lab I spent thinking about HOW to implement the code rather than
actually coding. Many of the labs we do in AP Comp Sci are self-governed/self-learned, meaning we often
have to go out and read the documentation ourselves while also teaching ourselves how to use the
code in our labs. In the Game of Life Lab, this was no different, and so while I disliked and got a bit
frustrated over the fact that the new code I was using wasn't producing the result I wanted, when I 
did get a working code I felt really satisfied. 
The most important advice I could offer next year's students is: DO NOT dive into coding right away 
thinking that you'll figure out the lab as you go. Instead, spend at least a couple days reading 
through all of the documentation, writing out pseudocodes and algorithms, and making sure your plans
work out with what the lab is asking you to do. Once you really understand the new methods and know
the details of what you want to code, then the actual coding aspect comes much easier. Otherwise, 
there's a good chance you'll just end up confusing yourself and producing a code that does not work
how you want it to (or how it should work).